/**
 * API.GEO.Carbone — Main Application
 *
 * ULTRA-FAST ARCHITECTURE:
 *
 * 1. Backend static cache (media/geocache/*.json)
 *    - Pre-built GeoJSON files served as static files (< 50ms)
 *    - Generated by: python manage.py prebuild_geojson
 *    - Fallback: dynamic PostGIS query if cache miss
 *
 * 2. Frontend memory cache (API._cache)
 *    - All 3 years preloaded in background on startup
 *    - Year switching: pure memory read (< 5ms)
 *
 * 3. Double-buffered rendering (Choropleth)
 *    - New layer added BEFORE old layer removed
 *    - No visual flicker, forests stay stable
 *
 * 4. Separate map panes with z-index isolation
 *    - Occupation, forests, limits, infrastructure each in own pane
 */
const App = {
    map: null,
    currentYear: 1986,
    currentForet: '',
    _loadDebounce: null,
    _foretsLoaded: false,
    _preloaded: false,

    async init() {
        console.log('[App] Init...');

        // Canvas renderer for performance
        this.map = L.map('map', {
            center: [6.5, -5.5],
            zoom: 10,
            zoomControl: true,
            preferCanvas: true,
            renderer: L.canvas({ padding: 0.5 }),
        });
        this.map.zoomControl.setPosition('bottomright');

        // ===== Map panes with z-index isolation =====
        this.map.createPane('occupationPane');
        this.map.getPane('occupationPane').style.zIndex = 400;

        this.map.createPane('foretsPane');
        this.map.getPane('foretsPane').style.zIndex = 450;

        this.map.createPane('limitesPane');
        this.map.getPane('limitesPane').style.zIndex = 460;

        this.map.createPane('infraPane');
        this.map.getPane('infraPane').style.zIndex = 470;

        // Init components
        LayerManager.init(this.map);
        Sidebar.init();
        Legend.init();
        TimeSlider.init((year) => this.onYearChange(year));
        ChatPanel.init(this.map);
        ReportGenerator.init();

        // Forest selector
        const foretSelect = document.getElementById('foret-select');
        if (foretSelect) {
            foretSelect.addEventListener('change', (e) => {
                this.currentForet = e.target.value;
                API.clearCachePrefix('/occupations/');
                this._preloaded = false;
                this.loadOccupation();
                Stats.load(this.currentYear, this.currentForet);
                // Preload all years for new forest
                this._backgroundPreload();
            });
        }

        // Occupation toggle
        const layerOcc = document.getElementById('layer-occupation');
        if (layerOcc) {
            layerOcc.addEventListener('change', (e) => {
                if (e.target.checked) {
                    this.map.addLayer(LayerManager.overlays.occupation);
                    this.loadOccupation();
                } else {
                    this.map.removeLayer(LayerManager.overlays.occupation);
                }
            });
        }

        await this.loadInitialData();
    },

    showLoading(text) {
        const el = document.getElementById('loading-overlay');
        const txt = document.getElementById('loading-text');
        if (el) el.classList.remove('hidden');
        if (txt) txt.textContent = text || 'Chargement...';
    },

    hideLoading() {
        const el = document.getElementById('loading-overlay');
        if (el) el.classList.add('hidden');
    },

    async loadInitialData() {
        this.showLoading('Chargement des forêts classées...');

        try {
            // 1. Forest boundaries — loaded ONCE, never cleared
            const forets = await API.getForets();
            if (forets?.features?.length > 0) {
                Choropleth.renderForets(forets, LayerManager.overlays.forets, this.map);
                this._foretsLoaded = true;

                // Populate forest selector
                const sel = document.getElementById('foret-select');
                if (sel) {
                    forets.features.forEach(f => {
                        const p = f.properties || {};
                        const opt = document.createElement('option');
                        opt.value = p.code;
                        opt.textContent = p.nom || p.code;
                        sel.appendChild(opt);
                    });
                }

                // Fit map to forest bounds
                const b = L.geoJSON(forets).getBounds();
                if (b.isValid()) this.map.fitBounds(b, { padding: [30, 30] });
            }
            console.log('[App] Forets:', forets?.features?.length || 0);

            // 2. Department boundaries — auto-loaded (with Oumé fallback)
            this.showLoading('Chargement des limites administratives...');
            await LayerManager.loadOverlay('limites');
            const cbLimites = document.getElementById('layer-limites');
            if (cbLimites) cbLimites.checked = true;
            this.map.addLayer(LayerManager.overlays.limites);

            // 3. Occupation du sol — year 1986
            this.showLoading('Chargement occupation du sol 1986...');
            await this.loadOccupation();

            // 4. Statistics
            this.showLoading('Statistiques...');
            await Stats.load(this.currentYear, this.currentForet);

        } catch (err) {
            console.error('[App] Init error:', err);
        }

        this.hideLoading();
        console.log('[App] ✓ Ready');

        // 5. BACKGROUND PRELOAD: fetch all 3 years into memory
        //    After this, year switching is instant (< 5ms)
        this._backgroundPreload();
    },

    /**
     * Background preload all years into browser memory cache.
     * Backend serves static files → fast parallel download.
     * After preload, year switching = pure memory read.
     */
    async _backgroundPreload() {
        if (this._preloaded) return;
        try {
            await API.preloadAllYears(this.currentForet);
            this._preloaded = true;
        } catch (err) {
            console.warn('[App] Preload (non-critical):', err);
        }
    },

    async loadOccupation() {
        try {
            const params = { annee: this.currentYear };
            if (this.currentForet) params.foret_code = this.currentForet;

            const t0 = performance.now();

            // Safety timeout: hide loading after 30s even if data hasn't arrived
            const timeoutId = setTimeout(() => {
                this.hideLoading();
                console.warn('[App] Occupation timeout (30s) — data may still arrive');
            }, 30000);

            const data = await API.getOccupations(params);
            clearTimeout(timeoutId);
            const dt = Math.round(performance.now() - t0);

            if (data?.features?.length > 0) {
                Choropleth.renderOccupation(data, LayerManager.overlays.occupation, this.map);
                console.log(`[App] Occupation ${this.currentYear}: ${data.features.length} polygones (${dt}ms)`);
            } else {
                LayerManager.overlays.occupation.clearLayers();
                console.warn(`[App] Occupation ${this.currentYear}: empty (${dt}ms)`);
            }
        } catch (err) {
            console.error('[App] Occupation error:', err);
        }
    },

    /**
     * Year change handler — near-instant after preload.
     * Debounced at 100ms for play mode.
     */
    async onYearChange(year) {
        this.currentYear = year;

        if (this._loadDebounce) clearTimeout(this._loadDebounce);
        this._loadDebounce = setTimeout(async () => {
            const layerOcc = document.getElementById('layer-occupation');
            if (!layerOcc || layerOcc.checked) {
                await this.loadOccupation();
            }
            Stats.load(year, this.currentForet);
        }, 100);
    },
};

document.addEventListener('DOMContentLoaded', () => {
    App.init().catch(err => console.error('[App] Fatal:', err));
});
